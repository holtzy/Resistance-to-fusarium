---
title: "Genetic Map Description"
output:
  rmdformats::material:
    highlight: kate
    self_contained: true
    code_folding: hide
    thumbnails: true
    gallery: true
    fig_width: 4
    fig_height: 4
---


#1/ Introduction

This file is a supplementary data attached with the publication concerning the genetic determinism of **Durum Wheat** to the **Fusarium head blight**. It aims to describe the **genetic map** provided in this paper. The script allowing to build the genetic map is in the folder **1_Partie_Bioinfo**.

Let's upload this genetic map:
```{r}
#Watch out, to reproduct analysis, you have to update the path.
map=read.table("/Users/yan/Dropbox/Publi_Fusariose/ANALYSIS_REPRO/DATA/map_avec_posi_physique.txt" , header=T )

# number of markers
nmark=nrow(map)
```

This genetic map is composed of **`r nmark` markers**. Putative **physical positions** of markers are available.

Charge some **libraries** that will be useful
```{r results='hide', message=FALSE, warning=FALSE}
library(RColorBrewer)
library(xtable)
library(tidyverse)
library(rmdformats)
```







#2/ Map description

## Summary table
Basic statistics are computed for **every chromosomes** of the genetic map, then for the **A** and **B genomes**, and finally for the **whole genetic map**. Results are presented in the table below:
```{r}
#Let's create a function that calculate some basic statistics for a piece of map
my_fun=function(my_map){
    num=nrow(bilan)
    num=num+1
    bilan[num,1]=i
    bilan[num,2]=nrow(my_map)
    bilan[num,3]=max(my_map[,3])
    gaps= sort(my_map[,3])[-1] - sort(my_map[,3])[-length(my_map[,3])]
    bilan[num,4]=mean(gaps)
    bilan[num,5]=max(gaps)
    bilan[num,6]=round(nrow(unique(my_map[,c(1,3)])),0)
    return(bilan)
    }

#Let's apply this function on our map, chromosome by chromosome and for the whole map:

# summary table that we are going to fill
bilan=data.frame(matrix(0,0,6)) ; num=0
colnames(bilan)=c("Chromo","nbr_marker","size_in_cM","average_gap","biggest_gap","nb_uniq_pos")

# apply the function to every chromosome
for(i in levels(map$group)){
    map_K=map[map$group==i,]
    bilan=my_fun(map_K)
    }
# then to A and B genomes
for(i in c("A" , "B")){
    map_K=map[substr(map$group , 2 , 2)==i , ]
    bilan=my_fun(map_K)
    }
# then to the whole map
i="tot"
bilan=my_fun(map)
```

```{r my_table1, results='asis', fig.align="center"}
print(xtable(bilan), type = "html", include.rownames = F , comment=FALSE)
```

This table is saved as a **supplementary material** for the publication.
```{r}
write.table(bilan, "../../../SUPPORTING_DATA/OR_map_feature.csv", sep=";", quote=F, row.names = F)
```



## Markers distribution (plot)
```{r}
ggplot(map, aes(y=position, x=group, color=ref)) + 
  geom_point() +
  scale_y_reverse() 
```






#3/ Marey map
For most of the SNPs, a physical position is available trough the Ensembl database. It is interesting to compare the physical and the genetic positions of markers when both informations are available.



##Graphic Representation
This is the "marey map" representation. We will produce a figure for the paper with this code.

```{r, fig.align='center', fig.height=9}
head(map)
levels(map$group)
levels(map$group_phy)
p=map %>% 
  filter(group==group_phy) %>% 
  ggplot(aes(x=position_phy, y=position, color=group, text=contig_map)) + 
    geom_point() + 
    facet_wrap(~chromo_map, scales="free") + 
    theme(legend.position="none", axis.text=element_blank() , axis.ticks= element_blank() 
    )
p
ggplotly(p)
```






##Summary statistics

```{r}
# First we modify a little the files to be able to merge them. It gives the "data" object:
POS$chromo_BW=as.factor(substr(POS$chromo_BW , 1 , 2))
fun=function(x){strsplit(x,"@")[[1]][1] }
map$contig=unlist(lapply(as.character(map[,2]) , fun))
data=merge(map , POS , by.x=4 , by.y=2 , all=F)
data=data[ , -1]

# Compute the extremity of each chromosomes:
extremity=merge(aggregate(POS$position_BW , by=list(POS$chromo_BW) , min) , aggregate(POS$position_BW , by=list(POS$chromo_BW) , max) , by.x=1 , by.y=1)

# Function that computes statistics for a piece of map
my_fun=function(my_map , i){
  num=nrow(bilan2)
  num=num+1
  bilan2[num,1]=i
  bilan2[num,2]=nrow(my_map)
  bilan2[num,3]=max(my_map[,3])
  gaps= sort(my_map[,3])[-1] - sort(my_map[,3])[-length(my_map[,3])]
  bilan2[num,4]=mean(gaps)
  bilan2[num,5]=max(gaps)
  common_map=merge(map,my_map , by.x=4 , by.y=2 , all=F)
  common_map=common_map[as.character(common_map$chromo_map) == as.character(common_map$chromo_BW) , ]
  bilan2[num,6]=nrow(common_map)
  bilan2[num,7]=round(cor(common_map$position_map , common_map$position_BW , method="spearman"),2)
  return(bilan2)
}

# we will store the results in a "bilan2"" table:
bilan2=data.frame(matrix(0,0,7))
colnames(bilan2)=c("Chromo","nbr marker","size in cM","average gap","biggest gap", "nbr_common_marker" , "Spearman")

# compute statistics for each chromosome separately:
for(i in levels(map$chromo_map)){
  map_K=POS[POS$chromo_BW==i,]
  bilan2=my_fun(map_K,i)
}
# then for A and B genomes:
for(i in c("A" , "B")){
  map_K=POS[substr(POS$chromo_BW , 2 , 2)==i , ]
  bilan2=my_fun(map_K,i)
}
# then for the whole map:
i="tot"
bilan2=my_fun(POS , i)

#Add these informations to the summary of the genetic map:
bilan=merge(bilan, bilan2[,c(1,6,7)] , by.x=1 , by.y=1)
```

```{r my_table2, results='asis'}
print(xtable(bilan), type = "html", include.rownames = F , comment=FALSE)
```

It is the table number one of the publication, so we save it also:
```{r}
write.table(x=bilan,file="/Users/yan/Dropbox/Publi_Fusariose/TABLES/table1.csv", quote=F, col.names=NA , row.names=T, sep=";")
```


##Graphic Representation
This is the "marey map" representation. We will produce a figure for the paper with this code.
	
```{r, message=FALSE, warning=FALSE , fig.height=10, fig.width=8}
# Plot preparation:
#png(filename = "/Users/yan/Dropbox/Publi_Fusariose/FIGURE/Fig_2.png" )
par(mfrow=c(4,4))
par(mar=c(2.5 , 2.5 , 0.5 , 0.5))

# We will store features of chromosomes in a summary table:
bilan_model=data.frame(matrix(0,14,6) ) ; colnames(bilan_model)=c("chromo" , "a" , "b x" , "c x2", "dx3" , "R2 adj")
bilan_outsider=data[0, ]
bilan_outsider2=data[0, ]
num=0

# For each chromosome:
for(i in levels(data$chromo_map)){
	
	# Plot each markers with both physical & genetic positions:
	don=data[data$chromo_map==i & data$chromo_BW==i & !is.na(data$chromo_BW) , ]
	if(nrow(don)==0){next}
	my_contigs=unlist(lapply(as.character(don$marker) , fun))
	plot(don$position_map ~ don$position_BW ,  xlab="" , ylab=""  , pch=20 , 
	     xlim=c(0,max(don$position_BW , na.rm=T)+20) , ylim=c(0,max(don$position_map , na.rm=T)+20) , 
	     col=ifelse( regexpr("Traes", don$marker) != -1 | regexpr("TRAES",don$marker) != -1  , "blue" , "red" ) , cex.axis=0.7)
	legend("topleft", paste(i," (",length(don$position_BW[!is.na(don$position_BW)]),")" , sep="") , 
	     cex=1 , text.col="black" , bty="n" )
	
	# Add 2 ablines for start and end of the chromosome
	abline(v=extremity[extremity[,1]==i ,c(2,3) ] , col="grey")
	
	# Let's add a polynomial regression:
	num=num+1
	bilan_model[num,1]=i
	y=don$position_map
	x=don$position_BW
	model=lm(y ~ x + I(x^2) + I(x^3))
	bilan_model[num , c(2:5)]=model$coefficients
	bilan_model[num , 6]=summary(model)$adj.r.squared
	myPredict <- predict( model , interval="predict" )
	ix <- sort(x,index.return=T)$ix
	lines(x[ix], myPredict[ix], col=2, lwd=2 )
	polygon(c(rev(x[ix]), x[ix]), c(rev(myPredict[ ix,3]), myPredict[ ix,2]), col = rgb(0.7,0.7,0.7,0.4) , border = NA)
	
	# Let's notice which are the SNPs far from the polynomial regression (="outsider")
	don$predict=myPredict[,1]
	AA=don[don$predict > don$position_map+15 | don$predict < don$position_map-15 , ]
	bilan_outsider=rbind(bilan_outsider , AA)
	
	# And notice which one are note in the confidence interval of the regression.
	confidence=    predict( model , interval="predict" )
	don$lwr=confidence[,2]
	don$upr=confidence[,3]
	BB=don[ don$position_map > confidence[,2] & don$position_map > confidence[,3] , ]
	bilan_outsider2=rbind(bilan_outsider2 , BB)
	
	}
```


	